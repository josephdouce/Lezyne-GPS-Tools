<!DOCTYPE html>
<html>
<head>
  <title>Map Tile Downloader</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
  <style>
    body { margin: 0; font-family: sans-serif; }
    #map { height: 60vh; width: 100%; }
    #status-log {
      background: #f4f4f4;
      border: 1px solid #ccc;
      padding: 10px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>

<h2>Select Area and Download Map Tiles</h2>
<div id="map"></div>

<form method="POST" action="/download" id="downloadForm">
  <input type="hidden" id="sw_lat" name="sw_lat" required>
  <input type="hidden" id="sw_lon" name="sw_lon" required>
  <input type="hidden" id="ne_lat" name="ne_lat" required>
  <input type="hidden" id="ne_lon" name="ne_lon" required>
  <p><strong>Tiles to download:</strong> <span id="tileCount">0</span></p>
  <button type="submit">Download</button>
</form>

<div id="status-log">
  {% if logs %}
    {% for line in logs %}
      {{ line }}<br>
    {% endfor %}
  {% else %}
    No download started yet.
  {% endif %}
</div>

<script>
const map = L.map('map');
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

navigator.geolocation.getCurrentPosition(
  pos => map.setView([pos.coords.latitude, pos.coords.longitude], 10),
  () => map.setView([54.5, -1.0], 9)
);

let tileLayerGroup = L.layerGroup().addTo(map);
let downloadedTileLayerGroup = L.layerGroup().addTo(map);
let drawnRectangle;

let drawControl = new L.Control.Draw({
  draw: {
    polygon: false, polyline: false, circle: false, marker: false, circlemarker: false,
    rectangle: { shapeOptions: { color: 'blue' } }
  },
  edit: { featureGroup: new L.FeatureGroup() }
});
let drawnItems = drawControl.options.edit.featureGroup;
map.addControl(drawControl);
drawnItems.addTo(map);

map.on('draw:created', function (e) {
  if (drawnRectangle) drawnItems.clearLayers();
  tileLayerGroup.clearLayers();

  drawnRectangle = e.layer;
  drawnItems.addLayer(drawnRectangle);

  const bounds = drawnRectangle.getBounds();
  const sw = bounds.getSouthWest();
  const ne = bounds.getNorthEast();

  document.getElementById('sw_lat').value = sw.lat.toFixed(6);
  document.getElementById('sw_lon').value = sw.lng.toFixed(6);
  document.getElementById('ne_lat').value = ne.lat.toFixed(6);
  document.getElementById('ne_lon').value = ne.lng.toFixed(6);

  let latStep = 0.1, lonStep = 0.2, overlap = 0.01;
  let tileCount = 0;
  for (let lat = sw.lat; lat < ne.lat; lat += latStep) {
    for (let lon = sw.lng; lon < ne.lng; lon += lonStep) {
      const tileSW = [lat, lon];
      const tileNE = [lat + latStep + overlap, lon + lonStep + overlap];
      L.rectangle([tileSW, tileNE], {
        color: "orange",
        weight: 1,
        fillOpacity: 0.2
      }).addTo(tileLayerGroup);
      tileCount++;
    }
  }

  document.getElementById('tileCount').innerText = tileCount;
});

function addDownloadedTiles(map) {
  downloadedTileLayerGroup.clearLayers();
  fetch('/downloaded_tiles')
    .then(res => res.json())
    .then(data => {
      data.tiles.forEach(tile => {
        const bounds = [[tile.sw.lat, tile.sw.lon], [tile.ne.lat, tile.ne.lon]];
        L.rectangle(bounds, {
          color: "green",
          weight: 1,
          fillOpacity: 0.2
        }).addTo(downloadedTileLayerGroup);
      });
    })
    .catch(err => console.error('Failed to load downloaded tiles:', err));
}

addDownloadedTiles(map);
</script>


<hr>
<h3>Visualize Previously Downloaded Tiles (.lzm)</h3>
<input type="file" id="folderPicker" webkitdirectory multiple />
<script>
document.getElementById('folderPicker').addEventListener('change', function (e) {
  const files = Array.from(e.target.files);
  const lzmFiles = files.filter(f => f.name.endsWith(".lzm"));
  const group = L.layerGroup().addTo(map);
  lzmFiles.forEach(file => {
    const name = file.name.replace(".lzm", "").replace("mf_", "");
    const parts = name.split("_");
    if (parts.length === 4) {
      const sw_lat = parseFloat(parts[0]);
      const sw_lon = parseFloat(parts[1]);
      const ne_lat = parseFloat(parts[2]);
      const ne_lon = parseFloat(parts[3]);
      if (!isNaN(sw_lat) && !isNaN(sw_lon) && !isNaN(ne_lat) && !isNaN(ne_lon)) {
        const bounds = [[sw_lat, sw_lon], [ne_lat, ne_lon]];
        L.rectangle(bounds, {
          color: "green",
          weight: 1,
          fillOpacity: 0.25
        }).addTo(group);
      }
    }
  });
});
</script>

</body>
</html>
